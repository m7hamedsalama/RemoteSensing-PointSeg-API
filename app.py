# -*- coding: utf-8 -*-
"""Untitled32.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nFiYPZuKxI8F3muNA70zTIM4RcF40eLx
"""

import os
import io
import numpy as np
import torch
import torchvision.transforms.functional as TF
import torchvision.models.segmentation as segmentation
from flask import Flask, request, jsonify, send_file
from PIL import Image

app = Flask(__name__)

# ==========================================
# 1. Model Initialization
# ==========================================
#  Free servers run on CPU, so we have to make the model run on it.
device = torch.device('cpu')
NUM_CLASSES = 5

print("Loading model architecture...")
model = segmentation.deeplabv3_resnet50(
    weights=None,
    weights_backbone=None,
    num_classes=NUM_CLASSES
)

#  Load the weights you trained
MODEL_PATH = 'model_50.pth'
if os.path.exists(MODEL_PATH):
    #  'map_location='cpu' is very necessary in case you trained on a GPU and want to upload it to a regular server
    model.load_state_dict(torch.load(MODEL_PATH, map_location=device))
    print("✅ Model weights loaded successfully!")
else:
    print(f"⚠️ Warning: {MODEL_PATH} not found!")

model.to(device)
model.eval()

# Class colors (so we can color the resulting Mask the same as in Jupyter)
# [Background, Class 1, Class 2, Class 3, Class 4] - These are approximate (RGB) colors
COLORS = np.array([
    [0, 0, 128],      #  [Background, Class 1, Class 2, Class 3, Class 4] - These are approximate (RGB) colors
    [0, 255, 0],      #  Green (Trees/Vegetation)
    [255, 165, 0],    # orange
    [255, 0, 0],      # red
    [0, 255, 255]     #  Heavenly
], dtype=np.uint8)

# ==========================================
#  2. Image Preprocessing
# ==========================================
def preprocess_image(image_bytes):
    image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
    image = image.resize((512, 512), Image.BILINEAR)
    image_tensor = TF.to_tensor(image)
    image_tensor = TF.normalize(image_tensor, mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    return image_tensor.unsqueeze(0)

# ==========================================
# 3. Prediction Path (API Endpoint)
# ==========================================
@app.route('/', methods=['GET'])
def home():
    return jsonify({"message": "Remote Sensing Segmentation API is running!"})

@app.route('/predict', methods=['POST'])
def predict():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected for uploading'}), 400

    try:
         # Image Reading
        img_bytes = file.read()
        input_tensor = preprocess_image(img_bytes).to(device)

        # Expectation
        with torch.no_grad():
            output = model(input_tensor)['out']
            pred_mask = torch.argmax(output, dim=1).squeeze(0).cpu().numpy()

        colored_mask = COLORS[pred_mask]

        result_image = Image.fromarray(colored_mask)
        byte_io = io.BytesIO()
        result_image.save(byte_io, 'PNG')
        byte_io.seek(0)

        return send_file(byte_io, mimetype='image/png')

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# ==========================================
# Start the server
# ==========================================
if __name__ == '__main__':
   # Port 0.0.0.0 allows servers (like Railway) to access the application
    app.run(host='0.0.0.0', port=os.environ.get("PORT", 5000), debug=False)

